# .github/workflows/ci-cd-pipeline.yml

name: DevOps Meme/Quote Generator CI/CD Pipeline

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]
  workflow_dispatch:

jobs:
  # --- Job: Build and Test ---
  build-test:
    name: 'Build & Test Docker Image'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub (or ECR)
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: samisondocker/devops-meme-quote-generator:${{ github.sha }}

  # --- Job: Terraform Plan ---
  terraform-plan:
    name: 'Terraform Plan'
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    needs: build-test

    permissions:
      contents: read
      pull-requests: write

    env:
      TF_VAR_ssh_key_name: ${{ secrets.TF_SSH_KEY_NAME }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./terraform

      - name: Terraform Plan
        id: plan
        run: |
          # Run plan and capture output
          PLAN_OUTPUT=$(terraform plan -no-color 2>&1)
          # Save to GITHUB_ENV
          echo "TF_PLAN<<EOF" >> $GITHUB_ENV
          echo "$PLAN_OUTPUT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          # Also save to file for debugging/artifacts
          echo "$PLAN_OUTPUT" > tfplan.txt
        working-directory: ./terraform
        continue-on-error: true

      - name: Comment Terraform Plan on PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const planOutput = process.env.TF_PLAN || "No plan output available.";
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## Terraform Plan Output\n\`\`\`hcl\n${planOutput}\n\`\`\``
            });
            
  # --- Job: Terraform Apply ---
  terraform-apply:
    name: 'Terraform Apply (Manual Approval Required)'
    if: (github.ref == 'refs/heads/master' && github.event_name == 'push') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: [build-test]

    environment:
      name: production
      url: ${{ steps.get_ip.outputs.public_ip_url }}

    env:
      TF_VAR_ssh_key_name: ${{ secrets.TF_SSH_KEY_NAME }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform

      - name: Terraform Validate
        run: terraform validate
        working-directory: ./terraform

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ./terraform

      - name: Get EC2 Public IP
        id: get_ip
        run: |
          export EC2_IP=$(terraform output -raw ec2_instance_public_ip)
          echo "EC2_IP=$EC2_IP" >> $GITHUB_ENV
          echo "public_ip_url=http://$EC2_IP:5000" >> $GITHUB_OUTPUT
        working-directory: ./terraform

# --- New Job: Ansible Configure Instance ---
ansible-configure:
  name: 'Ansible Configure Instance (Manual Approval Required)'
  # Run after Terraform apply, on master push or manual dispatch
  if: (github.ref == 'refs/heads/master' && github.event_name == 'push') || github.event_name == 'workflow_dispatch'
  runs-on: ubuntu-latest
  needs: [terraform-apply] # Must wait for infrastructure

  # --- Approval Gate using Environment ---
  environment:
    name: configure-production # Create this environment in GitHub settings if needed
    # url: ${{ steps.get_ip.outputs.public_ip_url }} # Optional, if you want a direct link

  steps:
    - name: Checkout
      uses: actions/checkout@v4

    # Setup Python for Ansible
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    # Install Ansible
    - name: Install Ansible
      run: |
        pip install --upgrade pip
        pip install ansible

    # Configure AWS credentials (might be needed if using dynamic inventory)
    - name: Configure AWS Credentials (for Ansible EC2 inventory if needed)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1 # Use the same region as your Terraform config

    # --- KEY PART: Setup SSH for Ansible ---
    # Store the private SSH key in GitHub Secrets (e.g., TF_SSH_PRIVATE_KEY)
    # It's crucial this secret contains the *private* key content, including
    # the "-----BEGIN OPENSSH PRIVATE KEY-----" and "-----END OPENSSH PRIVATE KEY-----" lines.
    - name: Setup SSH Key for Ansible
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.TF_SSH_PRIVATE_KEY }} # Add this secret!

    # Get Terraform Outputs (IP, potentially Image Tag if not using latest)
    - name: Get Terraform Outputs
      id: get_outputs
      run: |
        cd terraform
        # Ensure Terraform is initialized to read state from S3 backend
        terraform init || echo "Terraform init failed, but continuing..."
        export EC2_IP=$(terraform output -raw ec2_instance_public_ip)
        if [ -z "$EC2_IP" ]; then
          echo "ERROR: Could not retrieve EC2 Public IP from Terraform outputs."
          exit 1
        fi
        echo "EC2_IP=$EC2_IP" >> $GITHUB_ENV
        # Use the commit SHA as the image tag, matching the build-test job
        # IMPORTANT: Replace 'your-dockerhub-username' with your actual Docker Hub username!
        export IMAGE_TAG="samisondocker/devops-meme-quote-generator:${{ github.sha }}"
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
      # Ensure Terraform is initialized to read state

    # Create a simple Ansible inventory (or use ec2.py dynamic inventory)
    - name: Create Ansible Inventory
      run: |
        mkdir -p ansible/inventory
        cat > ansible/inventory/hosts <<EOF
        [web_app_hosts]
        web_app ansible_host=${{ env.EC2_IP }} ansible_user=ec2-user ansible_ssh_common_args='-o StrictHostKeyChecking=no'
        EOF

    # Run the Ansible Playbook
    - name: Run Ansible Playbook
      run: |
        cd ansible
        ansible-playbook -i inventory/hosts configure-web-app.yml \
          -e "docker_image_tag=${{ env.IMAGE_TAG }} ec2_public_ip=${{ env.EC2_IP }}"